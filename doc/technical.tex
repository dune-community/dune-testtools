\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{listings}
\lstset{language=C++, basicstyle=\ttfamily,
  stringstyle=\ttfamily, commentstyle=\it, extendedchars=true}

\title{Technical Documentation of \textbf{dnue-testtools}}

\author{
Timo Koch$^\ast$ \and
Dominic Kempf$^\dagger$
}

\date{April 16, 2015}

\begin{document}

\maketitle
\tableofcontents
\pagebreak

\section{Introduction}

The dune-testtools project is part of a project on quality assurance and reproducibility in numerical software frameworks. It is joint work between the dune-pdelab and the DuMuX development teams.

\section{The Meta Ini Format}

The meta ini format is used in dune-testtools as a domain specific language for feature modelling. It is an extension to the ini format as used in Dune. To reiterate the syntax of such ini file, see the EBNF in figure~\ref{fig:normalebnf} and example~\ref{lst:normalini}. Note that, you can define groups of keys either by using the \lstinline![..]! syntax, by putting dots into keys or by using a combination of both.

\begin{figure}
\begin{align*}
 <ini> & ::= \{<pair> | <group>\}^* \\
 <group> & ::= \underline{[}<str>\underline{]} \\
 <pair> & ::= <str>\underline{ = }<str>
\end{align*}
\caption{EBNF describing normal Dune style ini files.}
\label{fig:normalebnf}
\end{figure}

\begin{lstlisting}[caption={A normal DUNE-style ini file},label=lst:normalini]
 key = value
 somegroup.x = 1
 [somegroup]
 y = 2
 [somegroup.subgroup]
 z = 3
\end{lstlisting}

The meta ini format is an extension to the normal ini file, which describes a set of ini files within one file. You find the EBNF of the extended syntax in \ref{fig:metaebnf}. The rest of this section is about describing the semantics of the extensions.

\begin{figure}
\begin{align*}
 <ini> & ::= \{<pair> | <group> | <include> \}^* \\
 <group> & ::= \underline{[}<str>\underline{]} \\
 <pair> & ::= <str>\underline{ = }<value>\{\underline{|} <command>\}^* \\
 <value> & ::= <str>\{\underline{\{}<value>\underline{\}}\}^*<str> \\
 <command> & ::= <cmdname> \{<cmdargs>\}^* \\
 <include> & ::= \underline{include} <str>
\end{align*}
\caption{EBNF describing the expanded meta ini syntax.}
\label{fig:metaebnf}
\end{figure}

\subsection{The command syntax}

Commands can be applied to key/value pairs by using a pipe and then stating the command name and potential arguments. As you'd expect from a pipe, you can use multiple commands on single key/value pair. If so, the order of resolution is the following:
\begin{itemize}
 \item Commands with a command type of higher priority are executed first. The available command types in order of priority are: POST\_PARSE, PRE\_EXPANSION, POST\_EXPANSION, PRE\_RESOLUTION, POST\_RESOLUTION, PRE\_FILTERING, POST\_FILTERING, AT\_EXPANSION.
 \item Given multiple commands with the same type, commands are executed from left to right.
\end{itemize}

\subsection{The expand command}

The \lstinline!expand! command is the most important command, as it defines the mechanism to provide sets of ini files. The values of keys that have the expand command are expected to be comma-separated lists. That list is split and the set of configurations is updated to hold the product of all possibile values. Listing~\ref{lst:exp1} shows a simple example which yields 6 ini files.

\begin{lstlisting}[caption={A simple example of expanded keys},label=lst:exp1]
 key = foo, bar | expand
 someother = 1, 2, 3 | expand
\end{lstlisting}

Sometimes, you may not want to generate the product of possible values, but instead couple multiple key expansions. You can do that by providing an argument to the expand command. All expand commands with the same argument, will be expanded together. Having expand commands with the same argument but a differing number of camma separated values is not well-defined. Listing~\ref{lst:exp2} shows again a minimal example, which yields 2 configurations.

\begin{lstlisting}[caption={A simple example of expanded keys with argument},label=lst:exp2]
 key = 1, 2 | expand foo
 someother = 4, 5 | expand foo
\end{lstlisting}

The above mechanism can be combined at will. Listing~\ref{lst:exp3} shows an example, which yields 6 ini files.

\begin{lstlisting}[caption={A simple combining multiple expansions},label=lst:exp3]
 key = foo, bar | expand 1
 someother = 1, 2, 3 | expand
 bla = 1, 2 | expand 1
\end{lstlisting}

\subsection{Key-dependent values}
\label{sec:keydepend}

Whenever values that contain unescaped curly brackets, the string within those curly brackets will be interpreted as a key and will be replaced by the associated value (after expansion). This feature can be used as many times as you wish, even in a nested fashion, as long as no circular dependencies arise. See listing~\ref{lst:keydepend} for a complex example of the syntax. In that example one configuration with \lstinline!y=1! and one with \lstinline!y=2! would be generated.

\begin{lstlisting}[caption={A complex example of key-dependent value syntax},label=lst:keydepend]
 k = a, ubb | expand
 y = {bl{k}}
 bla = 1
 blubb = 2
\end{lstlisting}

\subsection{Other commands}

The following subsections describes all other general purpose commands, that exist in dune-testtools. This does not cover commands that are specific to certain testtools. Those are described in section~\ref{sec:testtools}.

\subsubsection{The unique command}

A key marked with the command \lstinline!unique! will be made unique throughout the set of generated ini files. This is done by appending a consecutive numbering scheme to those (and only those) values, that appear multiple times in the set. Some special keys like \lstinline!__name! (see section~\ref{sec:systemtest}) have the unique command applied automatically. \\

Using the curly bracket syntax to depend on keys which have the \lstinline!unique! command applied is not well-defined.

\subsubsection{Simple value-altering commands: tolower, toupper, eval}

\lstinline!tolower! is a command turning the given value to lowercase. \lstinline!toupper! converts to uppercase respectively. \\

The \lstinline!eval! command applies a simple expression parsing to the given value. The following operators are recognized: addition (\lstinline!+!), subtraction (\lstinline!-!), multiplication (\lstinline!*!), floating point division (\lstinline!/!), a power function(\lstinline!^!) and a unary minus (\lstinline!-!). Operands may be any literals, \lstinline!pi! is expanded to its value. See listing~\ref{lst:eval} for an example.

\begin{lstlisting}[caption={An example of the eval command},label=lst:eval]
 radius = 1, 2, 3 | expand
 circumference = 2 * {r} * pi | eval
\end{lstlisting}

Note that the \lstinline!eval! command is currently within the POST\_FILTERING priority group. That means you cannot have other values depend on the result with the curly bracket syntax.

\subsection{The include statement}
The \lstinline!include! statement can be used to paste the contents of another inifile into the current ini file. The positioning of the statement within the ini file defines the priority order of keys that appear on both files. All keys prior to the include statements are potentially overriden if they appear in the include. Likewise, all keys after the include will override those from the include file with the same name. See figure~\ref{fig:include} for a minimal example. \\

\begin{figure}
\begin{tabular}{ccc}
\begin{minipage}{.4\linewidth}
\begin{lstlisting}[title={include.ini}]
 x = new
 include other.ini
 y = new
\end{lstlisting}
\end{minipage}

\begin{minipage}{.3\linewidth}
\begin{lstlisting}[title={other.ini}]
 x = old
 y = old
\end{lstlisting}
\end{minipage}

\begin{minipage}{.3\linewidth}
\begin{lstlisting}[title={Result}]
 x = old
 y = new
\end{lstlisting}
\end{minipage}
\end{tabular}
\caption{A minimum example to illustrate the \lstinline!include! statement}
\label{fig:include}
\end{figure}

This command is not formulated as a command, because it does, by definition not operate on a key/value pair. For convenience, \lstinline!include! and \lstinline!import! are synonymous w.r.t. to this feature.

\section{Describing system tests with the Meta Ini Format}
\label{sec:systemtest}

\section{Testtools}
\label{sec:testtools}

\section{Buildbot configuration}

\end{document}
